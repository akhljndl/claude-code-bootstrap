[
  {
    "matcher": "tool == \"Edit\" && tool_input.file_path matches \"\\\\.py$\"",
    "hooks": [
      {
        "type": "command",
        "command": "node -e \"const{execFileSync}=require('child_process');const fs=require('fs');let d='';process.stdin.on('data',c=>d+=c);process.stdin.on('end',()=>{const i=JSON.parse(d);const p=i.tool_input?.file_path;if(p&&fs.existsSync(p)){try{execFileSync('ruff',['format',p],{stdio:['pipe','pipe','pipe']});execFileSync('ruff',['check','--fix',p],{stdio:['pipe','pipe','pipe']})}catch(e){}}console.log(d)})\""
      }
    ],
    "description": "Auto-format Python files with ruff after edits"
  },
  {
    "matcher": "tool == \"Edit\" && tool_input.file_path matches \"\\\\.py$\"",
    "hooks": [
      {
        "type": "command",
        "command": "node -e \"const fs=require('fs');let d='';process.stdin.on('data',c=>d+=c);process.stdin.on('end',()=>{const i=JSON.parse(d);const p=i.tool_input?.file_path;if(p&&fs.existsSync(p)){const c=fs.readFileSync(p,'utf8');const lines=c.split('\\n');const matches=[];lines.forEach((l,idx)=>{if(/\\bprint\\s*\\(/.test(l)&&!/^\\s*#/.test(l))matches.push((idx+1)+': '+l.trim())});if(matches.length){console.error('[Hook] WARNING: print() found in '+p);matches.slice(0,5).forEach(m=>console.error(m));console.error('[Hook] Consider using logging module instead')}}console.log(d)})\""
      }
    ],
    "description": "Warn about print() statements in Python files after edits"
  }
]
